// Generated by CoffeeScript 1.6.3
(function() {
  var FS, Q, USAGE, argv, batchUp, max, min, partition, positions, regionFilePattern, since, timeSeries, _,
    _this = this;

  FS = require("q-io/fs");

  Q = require("q");

  _ = require("underscore")._;

  argv = require('optimist').argv;

  USAGE = "USAGE: " + argv.$0 + " --dir <directory to process> --since <millis since epoch> [--show-differences]--out <file to output time series in>";

  if (!((argv.dir != null) && argv.out && argv.since)) {
    console.error(USAGE);
    process.exit(1);
  }

  since = parseInt(argv.since);

  console.dir(argv);

  partition = function(partitionSize) {
    return function(list) {
      var groups;
      groups = _.groupBy(list, function(value, index) {
        return Math.floor(index / partitionSize);
      });
      return _.map(groups, function(value) {
        return value;
      });
    };
  };

  batchUp = partition(100);

  regionFilePattern = /.+\/(\d+)\/regions$/;

  positions = {};

  timeSeries = {};

  max = Number.MIN_VALUE;

  min = Number.MAX_VALUE;

  FS.listTree(argv.dir).then(function(entries) {
    var batches, dispatchBatch, reads, regionFileNames;
    regionFileNames = _.filter(entries, function(e) {
      return regionFilePattern.test(e);
    });
    batches = batchUp(regionFileNames);
    console.log("Files to read: " + regionFileNames.length);
    console.log("Batches: " + batches.length);
    reads = function(fileNames) {
      return _.map(fileNames, function(f) {
        return FS.read(f).then(function(content) {
          var e;
          try {
            return {
              timestamp: parseInt(f.match(regionFilePattern)[1]),
              content: JSON.parse(content)
            };
          } catch (_error) {
            e = _error;
            console.warn("Ignoring " + f + ": " + e);
            return null;
          }
        });
      });
    };
    dispatchBatch = function(index, batches) {
      var batch;
      if (index < batches.length) {
        batch = batches[index];
        console.log("Doing batch " + (index + 1) + "/" + batches.length + " of length " + batch.length);
        return Q.all(reads(batch)).then(function(filesRead) {
          var entry, fileRead, tweets, tweetsAtTimestamp, _i, _j, _len, _len1, _ref;
          for (_i = 0, _len = filesRead.length; _i < _len; _i++) {
            fileRead = filesRead[_i];
            if (fileRead != null) {
              _ref = fileRead.content;
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                entry = _ref[_j];
                if (fileRead.timestamp >= since) {
                  positions[entry.name] = entry.geo;
                  tweetsAtTimestamp = timeSeries[fileRead.timestamp];
                  if (tweetsAtTimestamp == null) {
                    tweetsAtTimestamp = timeSeries[fileRead.timestamp] = {};
                  }
                  tweets = entry.summary.tweets;
                  tweetsAtTimestamp[entry.name] = tweets;
                  min = Math.min(min, tweets);
                  max = Math.max(max, tweets);
                }
              }
            }
          }
          return dispatchBatch(index + 1, batches);
        }, function(error) {
          return console.error(error);
        });
      }
    };
    return dispatchBatch(0, batches);
  }).then(function() {
    var diff, diffs, entry, latestCount, name, out, pair, prevCount, prevEntry, timestamp, tweets, tweetsAtTimestamp;
    out = {
      range: {
        min: min,
        max: max
      },
      data: (function() {
        var _results;
        _results = [];
        for (timestamp in timeSeries) {
          tweetsAtTimestamp = timeSeries[timestamp];
          _results.push({
            timestamp: timestamp,
            snapshot: (function() {
              var _results1;
              _results1 = [];
              for (name in tweetsAtTimestamp) {
                tweets = tweetsAtTimestamp[name];
                _results1.push({
                  name: name,
                  geo: positions[name],
                  summary: {
                    tweets: tweets
                  }
                });
              }
              return _results1;
            })()
          });
        }
        return _results;
      })()
    };
    if (argv['show-differences']) {
      console.log("Finding differences over time");
      max = Number.MIN_VALUE;
      min = Number.MAX_VALUE;
      out.data = (function() {
        var _i, _len, _ref, _results,
          _this = this;
        _ref = _.chain(out.data).zip(_.rest(out.data)).filter(function(p) {
          return p[1] != null;
        }).value();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          pair = _ref[_i];
          diffs = (function() {
            var _j, _len1, _ref1, _results1,
              _this = this;
            _ref1 = pair[1].snapshot;
            _results1 = [];
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              entry = _ref1[_j];
              latestCount = entry.summary.tweets;
              prevEntry = _.filter(pair[0].snapshot, function(e) {
                return e.name === entry.name;
              });
              diff = prevEntry[0] != null ? (prevCount = prevEntry[0].summary.tweets, latestCount - prevCount) : 0;
              min = Math.min(min, diff);
              max = Math.max(max, diff);
              _results1.push({
                name: entry.name,
                geo: entry.geo,
                summary: {
                  tweets: diff
                }
              });
            }
            return _results1;
          }).call(this);
          _results.push({
            timestamp: pair[1].timestamp,
            snapshot: _.filter(diffs, function(d) {
              return d.summary.tweets > 0;
            })
          });
        }
        return _results;
      }).call(_this);
      out.range = {
        min: min,
        max: max
      };
    }
    return FS.write(argv.out, JSON.stringify(out)).then(function() {
      return console.log("Wrote entries to " + argv.out);
    });
  }).fail(function(error) {
    return console.error(error);
  });

}).call(this);

/*
//@ sourceMappingURL=extractTimeSeries.map
*/
